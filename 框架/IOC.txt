1. IOC(Inversion of Control)控制反转,是一种设计思路,是一种面向对象的编程法则.
   即由IoC容器帮对象找相应的依赖对象并注入,而不是由对象主动去找.

2. DI(Dependency Injection)依赖注入,组件之间依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中.
   依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台.

3. 依赖注入是控制反转的一种实现.
  控制反转是一种思想
  依赖注入是一种设计模式

4. IOC所注重的是设计思想上，从一个常规的创建对象的做法，即new一个对象，转变成向IOC容器提交请求，被动的等待IOC容器返回资源给你,这期间
   资源的创建归容器控制.

5. 因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转.

6. 创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器

7.
  我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：

1) 软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B
   或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。
2) 软件系统在引入IOC容器之后，这种情形就完全改变了，如图2所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，
   所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。
通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来

8. 总结:
1) 控制反转是解耦合的思想：调用类只依赖于接口,而不依赖具体实现的类,减少了耦合,控制权交给了容器,运行时由容器决定将具体的实现动态的
   注入到调用类的对象中.
2) 依赖注入是将实例变量注入到对象中去.

9. 依赖注入的两种方式：设置注入和构造注入.

  依赖注入分为三种：
       接口注入：很少使用。
       设值注入：就是通过property元素控制调用setter方法，就是所谓的设值注入。
       构造注入：就是constructor-arg控制调用有参数的构造器，由构造器来注入被依赖组件。就是所谓的构造器注入.

10. 优点:
  1) IOC根据配置文件来创建对象;
  2) 增加新类非常方便,只需修改配置文件即可.
  3) IOC容器通过配置文件来确定需要注入的实例化对象,非常便于单元测试.

11. 控制反转是框架和库的关键区别所在.
