1. [推荐的学习Blog](http://www.cnblogs.com/xingele0917/p/4317577.html)

2. 学习的关键点:
Executor
ExecutorService
ScheduledExecutorService
Future
CountDownLatch
CyclicBarrier
Semaphore
ThreadFactory
BlockingQueue
DelayQueue
Locks
Phaser

3. 线程安全的实现:

1) 互斥同步： synchronized, ReentrantLock[阻塞同步]  【重量级锁】

2) 非阻塞同步： CAS

3) 无同步方案: ThreadLocal

4. 锁的状态:

无状态锁 ——> 偏向锁 ——> 轻量级锁 ——> 重量级锁

5. Java内存模型为我们提供了哪些保证以及在Java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性:

   并发编程的3个基本概念: 原子性, 可见性，有序性.

   1) 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。[类似于数据库里的事物概念]
      Java只保证了基本数据类型的变量读取和赋值操作才是原子性的, (在32位的jdk环境下, 对64位数据的读取不是原子性操作*，如long、double).

   2) 可见性: 是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值.
      cpu的高速缓存只与运行在该CPU中的线程有关 [数据在高速缓存中被操作,共享变量是在主内存中].
      缓存一致性协议的实现: [volatile 的实现]. Java提供volatile来保证可见性

   3) 有序性：即程序执行的顺序按照代码的先后顺序执行.
      在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序它不会影响单线程的运行结果，但是对多线程会有影响.

      [volatile可以禁止指令重排序的]

6. 指令重排序: 在执行程序时为了提高性能，编译器和处理器通常会对指令做重排序：
      编译器重排序: 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
      处理器重排序: 如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序

  指令重排序不会影响单线程执行的正确性, 但是会影响多线程执行的正确性

7. happens-before原则:

    1) 规定了前后两个操作满足离散数学中的偏序关系, 不是描述实际操作的先后顺序，它是用来描述可见性的一种规则.
       前一个操作的结果对后一个操作可见.

    2) 只是用于具有依赖性的语句之间,如果没有依赖关系则谈不上是否有这个happen-before关系.

    3) 理解[https://www.jianshu.com/p/1508eedba54d]

8. 
