1. Hashtable采用的是独占锁,ConcurrentHashMap同步容器是一个线程安全的哈希表,内部采用"锁分段"机制，进而提供性能.

2. 关于锁分段机制：
HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，
假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，
从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数
据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问

3. Hashtable采用synchronized来保证线程安全.

4. 多线程环境下: 使用HashMap进行put操作是会引起死循环.

5. 重排序:
    编译器生成指令的次序，可以不同于源代码所暗示的“显然”版本。
    处理器可以乱序或者并行的执行指令。
    缓存会改变写入提交到主内存的变量的次序。

6. ConcurrentHashMap是为了替代HashTable选择引入的,根据默认的并发级别(concurrency level)，Map被分割成16个部分并且由不同的锁控制

7. 应用场景:
  CHM适合读者数量超过写者的数量,当写者数量>=读着数量时,CHM的性能是低于Hashtable和synchronized Map.

  CHM适合做Cache,在程序启动时,可以被多个读线程请求.

  除了少数插入操作和删除操作外，绝大多数都是读取操作，而且读操作在大多数时候都是成功的.

  实现写的细节:
    1)用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。
    2)通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。

8. [ConcurrentHashMap总结](http://www.importnew.com/22007.html)
