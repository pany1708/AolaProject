1. 使用场景:
  1) 同时只有一个写者,其它的均为读者线程.
    - 程序标志
    - 程序一次性懒汉初始化的变量

2. 有序性 [java内存模型中的可见性,原子性和有序性];
   java中提供了2中来保证线程操作过程中的有序性:
      volatile其本身包含了"禁止指令重排序的语义",
      synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两
      个同步块只能串行执行。


3. java的弱同步机制: volatile.用来确保将变量的更新操作更新通知到其它的线程.

   编译器与运行时都会注意到这个变量是共享的.而不会将该变量的操作与其它内存操作一起重排序.

   在读取volatile类型的变量时总会返回最新写入的值。

   在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。


4. volatile 性能：
　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。

5. 禁止指令重排序优化:
   有volatile修饰的变量,在其赋值语句之后,会插入内存屏障,（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），

   只有一个CPU访问内存时，并不需要内存屏障

6. [推荐教程](http://www.cnblogs.com/zhengbin/p/5654805.html)
