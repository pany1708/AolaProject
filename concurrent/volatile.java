1. 使用场景:
  1) 同时只有一个写者,其它的均为读者线程.
    - 程序标志
    - 程序一次性懒汉初始化的变量

2. 有序性 [java内存模型中的可见性,原子性和有序性];
   java中提供了2中来保证线程操作过程中的有序性:
      volatile其本身包含了"禁止指令重排序的语义",
      synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两
      个同步块只能串行执行。


3. java的弱同步机制: volatile.用来确保将变量的更新操作更新通知到其它的线程.

   编译器与运行时都会注意到这个变量是共享的.而不会将该变量的操作与其它内存操作一起重排序.

   在读取volatile类型的变量时总会返回最新写入的值。

   在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。


4. volatile 性能：
　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。

5. 禁止指令重排序优化:
   有volatile修饰的变量,在其赋值语句之后,会插入内存屏障,（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），

   只有一个CPU访问内存时，并不需要内存屏障

6. [推荐教程](http://www.cnblogs.com/zhengbin/p/5654805.html)

7. 实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在。

8. 对于volatile变量_instance，所有的写（write）都将先行发生于读（read）

9. 先行发生的保障（happens-before guarantee）

10. 可以保证多线程下的可见性:
    1) 读volatile: 每当子线程某一语句要用到volatile变量时，都会从主线程重新拷贝一份，这样就保证子线程的会跟主线程的一致。
    2) 写volatile: 每当子线程某一语句要写volatile变量时，都会在写完后同步到主线程去，这样就保证主线程的变量及时更新。

11. 它不会引起线程上下文的切换和调度,是轻量级的synchronized[锁].

12. 理解volatile是怎么保证线程可见性的.
    保证了线程对共享变量的操作都是一致的

13. [http://cmsblogs.com/?p=2092]

14. volatile 读操作和普通变量几乎没有区别.
    写操作会慢一些.

15. 
