1. 重排序:为了提高性能,编译器和处理器会对指令做重排序,重排序分为3种:
   1) 编译器重排序,不改变单线程程序语义.
   2) CPU重排序:
       指令级并行重排序;
       内存系统重排序.

2. 重排序可能会导致多线程程序出现内存可见性的问题.

3.  插入特定的内存屏障来保证禁止重排序.

4. happens-before:
  操作可见性,必须保证hbr.<2个操作既可以在同一个线程内,也可以在不同的线程内>.

5. happens-before不保证操作的顺序,只保证前一个操作的执行的结果对后一个操作可见.

6. 重排序对多线程的影响：

7. 程序未正确同步时,可能存在数据竞争.JVM对数据竞争的定义:
   1) 在一个线程中写一个变量;
   2) 在另一个线程中读同一个变量;
   3) 并且读和写没有通过同步来排序.

8. 常用的同步原语: synchronized, volatile和final:

  volatitle对单个变量的读写进行了同步.

  1)对一个volatile 变量的读, 总是能看到(任意线程) 对这个volatile 变量最后的写入.

  2)同时锁的语义保证了临界区代码的执行具有原子性.

  3)volatile 写比volatile 读的开销大的多.

  synchronized锁:

  1) 锁让临界区互斥执行, 同时可以让释放锁的线程向获取同一锁的线程发送消息.

  2) happens-before 中的监视器的锁规则, 保证了线程间的可见性.


9. 在Java 中通过锁和循环CAS 的方式实现原子操作.

   基于缓存加锁或者总线加锁的方式来实现多CPU 间的原子操作.
